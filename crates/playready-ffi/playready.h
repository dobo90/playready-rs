/*! \file */
/*******************************************
 *                                         *
 *  File auto-generated by `::safer_ffi`.  *
 *                                         *
 *  Do not manually edit this file.        *
 *                                         *
 *******************************************/

#ifndef __RUST_PLAYREADY_FFI__
#define __RUST_PLAYREADY_FFI__
#ifdef __cplusplus
extern "C" {
#endif

/** <No documentation available> */
typedef struct playready_cdm playready_cdm_t;

/** \brief
 *  Creates new instance of `Cdm` from path to `.prd` file.
 *
 *  When successful function returns pointer to `Cdm` which needs to be deallocated by `playready_cdm_free`.
 *  Otherwise it returns `NULL` and pointer to `error_msg` that needs to be deallocated by `playready_error_message_free`.
 */
playready_cdm_t *
playready_cdm_create_from_prd (
    char const * prd_path,
    char * * error_msg);

/** \brief
 *  Deallocates `cdm`. If `NULL` is passed function will do nothing.
 */
void
playready_cdm_free (
    playready_cdm_t * cdm);

/** <No documentation available> */
typedef struct playready_session playready_session_t;

/** \brief
 *  Creates new `Session`.
 *
 *  Returned pointer should be deallocated by `playready_session_free`.
 */
playready_session_t *
playready_cdm_open_session (
    playready_cdm_t const * cdm);

/** \brief
 *  Deallocates `error_msg`. If `NULL` is passed function will do nothing.
 */
void
playready_error_message_free (
    char * error_msg);


#include <stddef.h>
#include <stdint.h>

typedef struct {
    uint8_t idx[16];
} uint8_16_array_t;

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct Vec_uint8 {
    /** <No documentation available> */
    uint8_t * ptr;

    /** <No documentation available> */
    size_t len;

    /** <No documentation available> */
    size_t cap;
} Vec_uint8_t;

/** <No documentation available> */
typedef struct playready_kid_ck {
    /** <No documentation available> */
    uint8_16_array_t kid;

    /** <No documentation available> */
    Vec_uint8_t ck;
} playready_kid_ck_t;

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct Vec_playready_kid_ck {
    /** <No documentation available> */
    playready_kid_ck_t * ptr;

    /** <No documentation available> */
    size_t len;

    /** <No documentation available> */
    size_t cap;
} Vec_playready_kid_ck_t;

/** \brief
 *  Deallocates `keys`. If `NULL` is passed function will do nothing.
 */
void
playready_keys_free (
    Vec_playready_kid_ck_t keys);

/** \brief
 *  Deallocates `challenge`. If `NULL` is passed function will do nothing.
 */
void
playready_license_challenge_free (
    char * challenge);

/** <No documentation available> */
typedef struct playready_pssh playready_pssh_t;

/** \brief
 *  Deallocates `pssh`. If `NULL` is passed function will do nothing.
 */
void
playready_pssh_free (
    playready_pssh_t * pssh);

/** \brief
 *  Creates new instance of `Pssh` from Base64 string.
 *
 *  When successful it returns a pointer to `Pssh` which needs to be deallocated by `playready_pssh_free`.
 *  If not successful it will return `NULL` and pointer to `error_msg` which needs to be deallocated by `playready_error_message_free`.
 */
playready_pssh_t *
playready_pssh_from_b64 (
    char const * b64,
    char * * error_msg);

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_uint8 {
    /** \brief
     *  Pointer to the first element (if any).
     */
    uint8_t const * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_ref_uint8_t;

/** \brief
 *  Creates new instance of `Pssh` from bytes.
 *
 *  When successful it returns a pointer to `Pssh` which needs to be deallocated by `playready_pssh_free`.
 *  If not successful it will return `NULL` and pointer to `error_msg` which needs to be deallocated by `playready_error_message_free`.
 */
playready_pssh_t *
playready_pssh_from_bytes (
    slice_ref_uint8_t bytes,
    char * * error_msg);

/** <No documentation available> */
typedef struct playready_wrm_header playready_wrm_header_t;

/** \brief
 *  Extracts first wrm header from `Pssh`.
 *
 *  Returned pointer should be passed to `playready_session_get_license_challenge` where it will be consumed (and deallocated).
 */
playready_wrm_header_t *
playready_pssh_get_first_wrm_header (
    playready_pssh_t const * pssh);

/** \brief
 *  Deallocates `session`. If `NULL` is passed function will do nothing.
 */
void
playready_session_free (
    playready_session_t * session);

/** \brief
 *  Returns keys from license response.
 *
 *  If successful (`error_msg` != `NULL`) return value needs to be deallocated by `playready_keys_free`.
 *  Otherwise it return `error_msg` which needs to be deallocated by `playready_error_message_free`.
 */
Vec_playready_kid_ck_t
playready_session_get_keys_from_challenge_response (
    playready_session_t const * session,
    char const * response,
    char * * error_msg);

/** \brief
 *  Returns license challenge.
 *
 *  Function consumes and deallocates `wrm_header`. It's recommended to set `wrm_header` to `NULL` after calling this function.
 *  If successful returned pointer should be freed by `playready_license_challenge_free`.
 *  Otherwise it returns `error_msg` which needs to deallocated by `playready_error_message_free`.
 */
char *
playready_session_get_license_challenge (
    playready_session_t const * session,
    playready_wrm_header_t * wrm_header,
    char * * error_msg);


#ifdef __cplusplus
} /* extern \"C\" */
#endif

#endif /* __RUST_PLAYREADY_FFI__ */
